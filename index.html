<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ì•„ê¸°ê³ ë˜ ì¿ ì•„</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans KR', 'Arial', sans-serif;
            background: linear-gradient(180deg, #001f3f 0%, #003d73 50%, #006ba6 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
            touch-action: none;
        }

        /* ë¬¼ê²° ì• ë‹ˆë©”ì´ì…˜ ë°°ê²½ */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                radial-gradient(circle at 20% 50%, rgba(255, 255, 255, 0.05) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 255, 255, 0.05) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        .game-container {
            position: relative;
            z-index: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            padding: 20px;
            width: 100%;
            height: 100vh;
            justify-content: center;
        }

        .game-title {
            font-size: 48px;
            font-weight: bold;
            color: #ffffff;
            text-shadow:
                0 0 10px rgba(74, 144, 226, 0.8),
                0 0 20px rgba(74, 144, 226, 0.6),
                2px 2px 4px rgba(0, 0, 0, 0.5);
            margin-bottom: 10px;
            animation: titleFloat 3s ease-in-out infinite;
        }

        @keyframes titleFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        .game-wrapper {
            position: relative;
            display: flex;
            gap: 20px;
            align-items: center;
        }

        /* ì™¼ìª½ ì¥ì‹ */
        .decoration-left, .decoration-right {
            display: flex;
            flex-direction: column;
            gap: 40px;
            opacity: 0.7;
        }

        /* ëª¨ë°”ì¼ í„°ì¹˜ ì»¨íŠ¸ë¡¤ ì˜ì—­ */
        .mobile-controls {
            display: none;
        }

        @media (max-width: 768px) {
            body {
                padding: 0;
                margin: 0;
                justify-content: flex-start;
                padding-bottom: env(safe-area-inset-bottom);
            }
            .game-title {
                font-size: 24px;
                margin: 10px 0 5px 0;
                padding-top: env(safe-area-inset-top);
            }
            .decoration-left, .decoration-right {
                display: none;
            }
            .game-container {
                padding: 5px;
                gap: 5px;
                height: auto;
            }
            #game {
                max-width: calc(100vw - 10px);
                max-height: 45vh;
                width: auto;
                height: auto;
            }
            .canvas-container {
                padding: 5px;
                max-width: 100%;
            }

            /* ëª¨ë°”ì¼ ì „ìš© ì»¨íŠ¸ë¡¤ ì˜ì—­ */
            .mobile-controls {
                display: block;
                width: 100%;
                background: rgba(0, 31, 63, 0.9);
                padding: 15px;
                padding-bottom: calc(15px + env(safe-area-inset-bottom));
                box-sizing: border-box;
                border-top: 2px solid rgba(74, 144, 226, 0.5);
                position: relative;
            }

            .control-area {
                width: 100%;
                height: 180px;
                display: flex;
                gap: 10px;
                margin-bottom: 10px;
            }

            .movement-pad {
                flex: 1;
                background: rgba(74, 144, 226, 0.2);
                border: 2px solid rgba(74, 144, 226, 0.5);
                border-radius: 10px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 16px;
                color: #fff;
                text-align: center;
                touch-action: none;
                position: relative;
            }

            .dash-button {
                width: 120px;
                background: rgba(255, 215, 0, 0.3);
                border: 2px solid rgba(255, 215, 0, 0.6);
                border-radius: 10px;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                font-size: 32px;
                color: #FFD700;
                text-align: center;
                touch-action: none;
            }

            .dash-button.active {
                background: rgba(255, 215, 0, 0.6);
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            }

            .dash-button-label {
                font-size: 12px;
                margin-top: 5px;
            }

            .mobile-instructions {
                color: #fff;
                font-size: 14px;
                line-height: 1.6;
                text-align: center;
            }

            .mobile-instructions p {
                margin: 5px 0;
            }

            .pause-button {
                position: fixed;
                top: calc(10px + env(safe-area-inset-top));
                right: calc(10px + env(safe-area-inset-right));
                width: 50px;
                height: 50px;
                background: rgba(74, 144, 226, 0.8);
                border: 2px solid #fff;
                border-radius: 10px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 28px;
                color: #fff;
                z-index: 1000;
                cursor: pointer;
                touch-action: manipulation;
            }
        }

        .pause-button {
            display: none;
        }

        @media (max-width: 768px) {
            .pause-button {
                display: flex;
            }
        }

        .seaweed {
            position: relative;
            width: 60px;
        }

        .seaweed-stem {
            width: 8px;
            height: 150px;
            background: linear-gradient(to bottom, #2d5016 0%, #4a7c29 50%, #2d5016 100%);
            border-radius: 10px;
            margin: 0 auto;
            animation: seaweedWave 3s ease-in-out infinite;
            transform-origin: bottom;
        }

        @keyframes seaweedWave {
            0%, 100% { transform: rotate(-5deg); }
            50% { transform: rotate(5deg); }
        }

        .seaweed:nth-child(1) .seaweed-stem { animation-delay: 0s; height: 120px; }
        .seaweed:nth-child(2) .seaweed-stem { animation-delay: 0.5s; height: 160px; }
        .seaweed:nth-child(3) .seaweed-stem { animation-delay: 1s; height: 140px; }

        .decoration-right .seaweed:nth-child(1) .seaweed-stem { animation-delay: 0.3s; height: 130px; }
        .decoration-right .seaweed:nth-child(2) .seaweed-stem { animation-delay: 0.8s; height: 150px; }
        .decoration-right .seaweed:nth-child(3) .seaweed-stem { animation-delay: 1.3s; height: 170px; }

        /* ê²Œì„ ìº”ë²„ìŠ¤ ì˜ì—­ */
        .canvas-container {
            position: relative;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 20px;
            box-shadow:
                0 0 30px rgba(0, 0, 0, 0.3),
                inset 0 0 50px rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
        }

        #game {
            display: block;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            cursor: default;
        }

        /* ë¬¼ë°©ìš¸ ì¥ì‹ */
        .bubble {
            position: fixed;
            bottom: -50px;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0.2));
            border-radius: 50%;
            opacity: 0.6;
            animation: bubbleRise 10s infinite;
            z-index: 0;
        }

        @keyframes bubbleRise {
            0% {
                bottom: -50px;
                opacity: 0;
            }
            10% {
                opacity: 0.6;
            }
            90% {
                opacity: 0.6;
            }
            100% {
                bottom: 110vh;
                opacity: 0;
            }
        }

        .bubble:nth-child(1) { left: 10%; animation-delay: 0s; animation-duration: 8s; }
        .bubble:nth-child(2) { left: 25%; animation-delay: 2s; animation-duration: 10s; width: 15px; height: 15px; }
        .bubble:nth-child(3) { left: 40%; animation-delay: 4s; animation-duration: 12s; width: 25px; height: 25px; }
        .bubble:nth-child(4) { left: 55%; animation-delay: 1s; animation-duration: 9s; }
        .bubble:nth-child(5) { left: 70%; animation-delay: 3s; animation-duration: 11s; width: 18px; height: 18px; }
        .bubble:nth-child(6) { left: 85%; animation-delay: 5s; animation-duration: 13s; }
    </style>
</head>
<body>
    <!-- ë¬¼ë°©ìš¸ íš¨ê³¼ -->
    <div class="bubble"></div>
    <div class="bubble"></div>
    <div class="bubble"></div>
    <div class="bubble"></div>
    <div class="bubble"></div>
    <div class="bubble"></div>

    <div class="game-container">
        <h1 class="game-title">ğŸ‹ ì•„ê¸°ê³ ë˜ ì¿ ì•„ ğŸ‹</h1>

        <div class="game-wrapper">
            <!-- ì™¼ìª½ ë¯¸ì—­ ì¥ì‹ -->
            <div class="decoration-left">
                <div class="seaweed"><div class="seaweed-stem"></div></div>
                <div class="seaweed"><div class="seaweed-stem"></div></div>
                <div class="seaweed"><div class="seaweed-stem"></div></div>
            </div>

            <!-- ê²Œì„ ìº”ë²„ìŠ¤ -->
            <div class="canvas-container">
                <canvas id="game" width="800" height="800"></canvas>
            </div>

            <!-- ì˜¤ë¥¸ìª½ ë¯¸ì—­ ì¥ì‹ -->
            <div class="decoration-right">
                <div class="seaweed"><div class="seaweed-stem"></div></div>
                <div class="seaweed"><div class="seaweed-stem"></div></div>
                <div class="seaweed"><div class="seaweed-stem"></div></div>
            </div>
        </div>

    </div>

    <!-- ëª¨ë°”ì¼ ì „ìš© ì»¨íŠ¸ë¡¤ ì˜ì—­ -->
    <div class="mobile-controls">
        <div class="control-area">
            <div class="movement-pad" id="movementPad">
                <div>
                    ğŸ‘† ì´ë™<br>
                    (ì¡°ì´ìŠ¤í‹±)
                </div>
            </div>
            <div class="dash-button" id="dashButton">
                âš¡
                <div class="dash-button-label">ëŒ€ì‹œ</div>
            </div>
        </div>
        <div class="mobile-instructions">
            <p>ğŸ‹ ì‘ì€ ë¬¼ê³ ê¸°ë¥¼ ë¨¹ê³  ì„±ì¥í•˜ì„¸ìš”</p>
            <p>âš ï¸ ë¹¨ê°„ í…Œë‘ë¦¬ ë¬¼ê³ ê¸°ì™€ ìƒì–´ë¥¼ í”¼í•˜ì„¸ìš”</p>
            <p>â­ ë³„ì„ ë¨¹ìœ¼ë©´ ë¬´ì  ìƒíƒœ!</p>
        </div>
    </div>

    <!-- ëª¨ë°”ì¼ ì „ìš© ì¼ì‹œì •ì§€ ë²„íŠ¼ -->
    <div class="pause-button" id="pauseButton">â¸ï¸</div>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        
        let player = {x:400, y:400, radius:8, speed:3, score:0, level:1, foodEaten:0, isInvincible:false, invincibleTime:0, combo:0, lastMoveX:0, lastMoveY:0, stamina:100, maxStamina:100, isDashing:false, velocityX:0, velocityY:0, isSlowed:false, slowTime:0};
        let mouse = {x:400, y:400};
        let usingKeyboard = false;
        let touchStartX = 0;
        let touchStartY = 0;
        let isTouching = false;
        let isDashPressed = false; // ëŒ€ì‹œ ë²„íŠ¼ ëˆŒë¦¼ ìƒíƒœ
        let touchCount = 0;
        let fishes = [];
        let sharks = [];
        let powerUps = [];
        let bonusFish = [];
        let particles = [];
        let urchins = []; // ì„±ê²Œ
        let keys = {};
        let mousePressed = false;
        let gameState = 'intro';
        let warningTime = 0;
        let fishSpawnTimer = 0;
        let sharkSpawnTimer = 0;
        let gameTime = 0;
        let gameStartTime = 0;
        let gameClearTime = 0;
        let levelUpFlash = 0;
        let audioContext;
        let isMuted = false;
        let isPaused = false;

        // BGM ì‹œìŠ¤í…œ
        let bgmAudios = {
            1: new Audio('music/1.mp3'),
            2: new Audio('music/2.mp3'),
            3: new Audio('music/3.mp3'),
            4: new Audio('music/4.mp4')
        };
        let currentBGM = null;
        let currentBGMLevel = 0;
        let isFading = false;

        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch(e) {
                console.log('Audio not supported');
            }

            // ëª¨ë“  BGM ì‚¬ì „ ë¡œë“œ ë° ë£¨í”„ ì„¤ì •
            Object.values(bgmAudios).forEach(audio => {
                audio.loop = true;
                audio.volume = 0;
                audio.preload = 'auto';

                // ended ì´ë²¤íŠ¸ë¡œë„ ë£¨í”„ ë³´ì¥
                audio.addEventListener('ended', function() {
                    if(this === currentBGM && !isMuted && gameState === 'playing' && !isPaused) {
                        this.currentTime = 0;
                        this.play().catch(e => console.log('BGM loop error:', e));
                    }
                });

                audio.load();
            });
        }

        // ëª¨ë°”ì¼ì—ì„œ ì˜¤ë””ì˜¤ í™œì„±í™” (í„°ì¹˜ë¡œ ì‹œì‘)
        function unlockAudio() {
            if(audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        function getBGMForLevel(level) {
            if(level >= 1 && level <= 2) return bgmAudios[1];
            if(level >= 3 && level <= 5) return bgmAudios[2];
            if(level >= 6 && level <= 7) return bgmAudios[3];
            if(level >= 8 && level <= 10) return bgmAudios[4];
            return null;
        }

        function startBGM() {
            if(isMuted) return;
            updateBGM();
        }

        function stopBGM() {
            isFading = false; // í˜ì´ë”© í”Œë˜ê·¸ ì´ˆê¸°í™”

            if(currentBGM) {
                currentBGM.pause();
                currentBGM.currentTime = 0;
                currentBGM.volume = 0;
            }

            // ëª¨ë“  BGM ì •ì§€
            Object.values(bgmAudios).forEach(audio => {
                audio.pause();
                audio.currentTime = 0;
                audio.volume = 0;
            });

            currentBGM = null;
            currentBGMLevel = 0;
        }

        function pauseBGM() {
            if(currentBGM && !currentBGM.paused) {
                currentBGM.pause();
            }
        }

        function resumeBGM() {
            if(currentBGM && currentBGM.paused && !isMuted) {
                currentBGM.play().catch(e => console.log('BGM resume error:', e));
            }
        }

        function updateBGM() {
            if(isMuted || isFading) return;

            let targetBGM = getBGMForLevel(player.level);

            // ê°™ì€ ìŒì•…ì´ë©´ ë³€ê²½í•˜ì§€ ì•ŠìŒ
            if(currentBGM === targetBGM) return;

            isFading = true;

            // ì´ì „ BGM í˜ì´ë“œ ì•„ì›ƒ
            if(currentBGM) {
                fadeOut(currentBGM, () => {
                    currentBGM.pause();
                    currentBGM.currentTime = 0;

                    // ìƒˆ BGM í˜ì´ë“œ ì¸
                    currentBGM = targetBGM;
                    currentBGMLevel = player.level;
                    if(currentBGM && !isMuted) {
                        currentBGM.play().catch(e => console.log('BGM play error:', e));
                        fadeIn(currentBGM, () => {
                            isFading = false;
                        });
                    } else {
                        isFading = false;
                    }
                });
            } else {
                // ì²˜ìŒ ì‹œì‘ ì‹œ ë°”ë¡œ í˜ì´ë“œ ì¸
                currentBGM = targetBGM;
                currentBGMLevel = player.level;
                if(currentBGM && !isMuted) {
                    currentBGM.play().catch(e => console.log('BGM play error:', e));
                    fadeIn(currentBGM, () => {
                        isFading = false;
                    });
                } else {
                    isFading = false;
                }
            }
        }

        function fadeIn(audio, callback) {
            if(!audio) return;
            audio.volume = 0;
            let volume = 0;
            let fadeInterval = setInterval(() => {
                volume += 0.02;
                if(volume >= 0.5) {
                    volume = 0.5;
                    audio.volume = volume;
                    clearInterval(fadeInterval);
                    if(callback) callback();
                } else {
                    audio.volume = volume;
                }
            }, 50);
        }

        function fadeOut(audio, callback) {
            if(!audio) return;
            let volume = audio.volume;
            let fadeInterval = setInterval(() => {
                volume -= 0.02;
                if(volume <= 0) {
                    volume = 0;
                    audio.volume = volume;
                    clearInterval(fadeInterval);
                    if(callback) callback();
                } else {
                    audio.volume = volume;
                }
            }, 50);
        }

        
        function playSound(frequency, duration, type = 'sine') {
            if(!audioContext || isMuted) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            oscillator.type = type;
            
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }
        
        function toggleMute() {
            isMuted = !isMuted;

            if(isMuted) {
                // ìŒì†Œê±° ì‹œ ëª¨ë“  BGM ì •ì§€
                Object.values(bgmAudios).forEach(audio => {
                    audio.pause();
                    audio.currentTime = 0;
                });
                currentBGM = null;
            } else if(gameState === 'playing') {
                // ìŒì†Œê±° í•´ì œ ì‹œ BGM ì¬ê°œ
                startBGM();
            }
        }
        
        const fishStages = [
            {stage: 1, radius: 5, color: '#FFD700', points: 10},    // ë°ì€ ë…¸ë€ìƒ‰
            {stage: 2, radius: 12, color: '#FF8C00', points: 20},   // ì£¼í™©ìƒ‰
            {stage: 3, radius: 15, color: '#FF4500', points: 30},   // ì˜¤ë Œì§€ë ˆë“œ
            {stage: 4, radius: 18, color: '#C71585', points: 40},   // ë¯¸ë””ì—„ ë°”ì´ì˜¬ë › ë ˆë“œ
            {stage: 5, radius: 21, color: '#8B008B', points: 50},   // ì§„í•œ ë§ˆì  íƒ€
            {stage: 6, radius: 24, color: '#4B0082', points: 60},   // ì¸ë””ê³ 
            {stage: 7, radius: 27, color: '#6B0041', points: 70},   // ë‹¤í¬ ë²„ê±´ë””
            {stage: 8, radius: 30, color: '#8B0000', points: 80}    // ì–´ë‘ìš´ ë¹¨ê°„ìƒ‰
        ];

        function getPlayerRadius() {
            return 8 + (player.level - 1) * 4 + player.foodEaten;
        }

        function spawnFish() {
            let baseSpeed = 0.6 + (player.level - 1) * 0.03;
            let speed = baseSpeed * (0.6 + Math.random() * 0.3);

            let side = Math.floor(Math.random() * 4);
            let x, y, speedX, speedY;

            switch(side) {
                case 0:
                    x = 820;
                    y = Math.random() * 700 + 50;
                    speedX = -speed;
                    speedY = 0;
                    break;
                case 1:
                    x = -20;
                    y = Math.random() * 700 + 50;
                    speedX = speed;
                    speedY = 0;
                    break;
                case 2:
                    x = Math.random() * 700 + 50;
                    y = 820;
                    speedX = (Math.random() - 0.5) * speed * 0.8;
                    speedY = -speed;
                    break;
                case 3:
                    x = Math.random() * 700 + 50;
                    y = -20;
                    speedX = (Math.random() - 0.5) * speed * 0.8;
                    speedY = speed;
                    break;
            }

            let maxStage;
            if(player.level >= 8) {
                maxStage = 8;
            } else {
                maxStage = Math.min(player.level + 1, 8);
            }

            // ì  ë¬¼ê³ ê¸°(ë‹¤ìŒ ë ˆë²¨) ë“±ì¥ í™•ë¥  ì¦ê°€
            let stage;
            if(player.level < 8 && Math.random() < 0.4) {
                // 40% í™•ë¥ ë¡œ ì  ë¬¼ê³ ê¸°(ë‹¤ìŒ ë ˆë²¨) ë“±ì¥
                stage = player.level + 1;
            } else {
                // ë‚˜ë¨¸ì§€ëŠ” ê¸°ì¡´ ë¡œì§
                let availableStages = maxStage - (player.level < 8 ? 1 : 0);
                stage = Math.floor(Math.random() * availableStages) + 1;
                if(player.level < 8 && stage >= player.level + 1) {
                    stage = Math.min(stage, player.level);
                }
            }
            let fishData = fishStages[stage - 1];

            fishes.push({
                x: x,
                y: y,
                radius: fishData.radius,
                speedX: speedX,
                speedY: speedY,
                floatY: Math.random() * Math.PI * 2,
                floatSpeed: 0.02 + Math.random() * 0.01,
                floatAmplitude: 10 + Math.random() * 15,
                stage: stage,
                color: fishData.color,
                points: fishData.points
            });
        }
        
        function spawnPowerUp() {
            if(Math.random() < 0.3) { // 30%ë¡œ ì¦ê°€ (ë” ìì£¼ ë“±ì¥)
                let side = Math.floor(Math.random() * 4);
                let x, y, speedX, speedY;

                switch(side) {
                    case 0: x = 820; y = Math.random() * 700 + 50; speedX = -0.8; speedY = 0; break;
                    case 1: x = -20; y = Math.random() * 700 + 50; speedX = 0.8; speedY = 0; break;
                    case 2: x = Math.random() * 700 + 50; y = 820; speedX = 0; speedY = -0.8; break;
                    case 3: x = Math.random() * 700 + 50; y = -20; speedX = 0; speedY = 0.8; break;
                }

                powerUps.push({
                    x: x, y: y, radius: 10, speedX: speedX, speedY: speedY,
                    floatY: Math.random() * Math.PI * 2, floatSpeed: 0.03, floatAmplitude: 20
                });
            }
            
            if(Math.random() < 0.02) {
                let side = Math.floor(Math.random() * 4);
                let x, y, speedX, speedY;
                
                switch(side) {
                    case 0: x = 820; y = Math.random() * 700 + 50; speedX = -0.6; speedY = 0; break;
                    case 1: x = -20; y = Math.random() * 700 + 50; speedX = 0.6; speedY = 0; break;
                    case 2: x = Math.random() * 700 + 50; y = 820; speedX = 0; speedY = -0.6; break;
                    case 3: x = Math.random() * 700 + 50; y = -20; speedX = 0; speedY = 0.6; break;
                }
                
                bonusFish.push({
                    x: x, y: y, radius: 12, speedX: speedX, speedY: speedY,
                    floatY: Math.random() * Math.PI * 2, floatSpeed: 0.02, floatAmplitude: 25
                });
            }
        }
        
        
        function spawnShark() {
            let side = Math.floor(Math.random() * 4);
            let x, y;

            switch(side) {
                case 0: x = -60; y = Math.random() * 800; break;
                case 1: x = 860; y = Math.random() * 800; break;
                case 2: x = Math.random() * 800; y = -60; break;
                case 3: x = Math.random() * 800; y = 860; break;
            }

            sharks.push({
                x: x,
                y: y,
                size: 45,
                speed: 1.3
            });
        }

        function spawnUrchin() {
            // ì„±ê²ŒëŠ” ìœ„/ì•„ë˜ì—ì„œ ë“±ì¥í•˜ì—¬ ì§€ë‚˜ê°
            let side = Math.random() < 0.5 ? 2 : 3; // ìœ„(2) ë˜ëŠ” ì•„ë˜(3)ë§Œ
            let x, y, speedX, speedY;

            if(side === 2) {
                // ì•„ë˜ì—ì„œ ìœ„ë¡œ
                x = Math.random() * 700 + 50;
                y = 820;
                speedX = 0;
                speedY = -0.5; // ì²œì²œíˆ ìœ„ë¡œ
            } else {
                // ìœ„ì—ì„œ ì•„ë˜ë¡œ
                x = Math.random() * 700 + 50;
                y = -20;
                speedX = 0;
                speedY = 0.5; // ì²œì²œíˆ ì•„ë˜ë¡œ
            }

            urchins.push({
                x: x,
                y: y,
                radius: 20,
                speedX: speedX,
                speedY: speedY
            });
        }
        
        function drawTriangle(x, y, size, rotation) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);
            ctx.beginPath();
            ctx.moveTo(size, 0);
            ctx.lineTo(-size/2, -size/2);
            ctx.lineTo(-size/2, size/2);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }
        
        function drawCua(x, y, radius, moveX, moveY, isGameOver = false) {
            ctx.save();
            ctx.translate(x, y);

            // ëŒ€ì‹œ ì¤‘ì¼ ë•Œ ë¹›ë‚˜ëŠ” íš¨ê³¼
            if(player.isDashing && player.stamina > 0) {
                ctx.save();
                let dashGlow = radius * 2.2;
                let glowGradient = ctx.createRadialGradient(0, 0, radius, 0, 0, dashGlow);
                glowGradient.addColorStop(0, 'rgba(255, 223, 0, 0.6)');
                glowGradient.addColorStop(0.5, 'rgba(255, 165, 0, 0.4)');
                glowGradient.addColorStop(1, 'rgba(255, 140, 0, 0)');

                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(0, 0, dashGlow, 0, Math.PI * 2);
                ctx.fill();

                // ë¹›ë‚˜ëŠ” ì™¸ê³½ì„ 
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 4;
                ctx.shadowColor = '#FFD700';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(0, 0, radius * 1.5, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;
                ctx.restore();
            }

            // ìŠ¤í…Œë¯¸ë‚˜ ë¶€ì¡±ìœ¼ë¡œ ëŒ€ì‹œ ëª»í•  ë•Œ ì ë©¸ íš¨ê³¼
            if((keys[' '] || mousePressed || isDashPressed) && player.stamina <= 5) {
                let blinkAlpha = Math.sin(gameTime * 0.3) * 0.5 + 0.5; // 0~1 ì‚¬ì´ë¡œ ì ë©¸
                ctx.save();
                ctx.globalAlpha = blinkAlpha;
                ctx.strokeStyle = '#FF4444';
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(0, 0, radius * 1.3, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.restore();
            }

            // ë¬´ì  ë³´í˜¸ë§‰ ê·¸ë¦¬ê¸°
            if(player.isInvincible) {
                ctx.save();
                let shieldRadius = radius * 1.8;
                let gradient = ctx.createRadialGradient(0, 0, radius * 1.2, 0, 0, shieldRadius);
                gradient.addColorStop(0, 'rgba(255, 105, 180, 0)');
                gradient.addColorStop(0.7, 'rgba(255, 105, 180, 0.4)');
                gradient.addColorStop(1, 'rgba(255, 105, 180, 0.8)');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, shieldRadius, 0, Math.PI * 2);
                ctx.fill();

                // ë³´í˜¸ë§‰ ì™¸ê³½ì„ 
                ctx.strokeStyle = '#FF69B4';
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.restore();
            }

            let angle = 0;
            if(moveX !== 0 || moveY !== 0) {
                angle = Math.atan2(moveY, moveX);
            }
            ctx.rotate(angle);

            ctx.fillStyle = '#4A90E2';
            ctx.globalAlpha = 1.0;

            ctx.beginPath();
            ctx.ellipse(0, 0, radius * 1.2, radius * 0.8, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = Math.max(1, radius * 0.05);
            ctx.stroke();

            ctx.fillStyle = '#4A90E2';
            ctx.beginPath();
            ctx.arc(-radius * 1.5, 0, radius * 0.6, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = Math.max(2, radius * 0.08);
            ctx.stroke();
            
            ctx.fillStyle = '#000';
            ctx.globalAlpha = 1.0;
            
            let eyeOffset = radius * 0.4;
            ctx.beginPath();
            ctx.arc(eyeOffset, -radius * 0.3, radius * 0.15, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(eyeOffset, radius * 0.3, radius * 0.15, 0, Math.PI * 2);
            ctx.fill();
            
            
            ctx.restore();
        }
        
        function drawFish(x, y, radius, color = '#FF6B6B', direction = -1, stage = 1, isEnemy = false) {
            ctx.save();
            ctx.translate(x, y);

            if(typeof direction === 'number' && direction > 10) {
                ctx.rotate(direction === 90 ? -Math.PI/2 : Math.PI/2);
            } else if(direction > 0) {
                ctx.scale(-1, 1);
            }

            let borderColor = isEnemy ? '#FF0000' : '#FFF';

            ctx.fillStyle = color;

            ctx.beginPath();
            ctx.ellipse(0, 0, radius * 1.2, radius * 0.8, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = borderColor;
            ctx.lineWidth = Math.max(2, radius * 0.08);
            ctx.stroke();

            ctx.fillStyle = color;
            if(stage >= 6) {
                // ì‚¼ì¤‘ ê¼¬ë¦¬ (6ë‹¨ê³„ ì´ìƒ)
                ctx.beginPath();
                ctx.moveTo(radius * 1.2, 0);
                ctx.lineTo(radius * 1.8, -radius * 0.9);
                ctx.lineTo(radius * 1.6, -radius * 0.3);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = borderColor;
                ctx.lineWidth = Math.max(2, radius * 0.08);
                ctx.stroke();

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(radius * 1.2, 0);
                ctx.lineTo(radius * 1.9, 0);
                ctx.lineTo(radius * 1.6, 0);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = borderColor;
                ctx.lineWidth = Math.max(2, radius * 0.08);
                ctx.stroke();

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(radius * 1.2, 0);
                ctx.lineTo(radius * 1.8, radius * 0.9);
                ctx.lineTo(radius * 1.6, radius * 0.3);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = borderColor;
                ctx.lineWidth = Math.max(2, radius * 0.08);
                ctx.stroke();
            } else if(stage >= 3) {
                // ì´ì¤‘ ê¼¬ë¦¬ (3-5ë‹¨ê³„)
                ctx.beginPath();
                ctx.moveTo(radius * 1.2, 0);
                ctx.lineTo(radius * 1.8, -radius * 0.8);
                ctx.lineTo(radius * 1.6, -radius * 0.2);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = borderColor;
                ctx.lineWidth = Math.max(2, radius * 0.08);
                ctx.stroke();

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(radius * 1.2, 0);
                ctx.lineTo(radius * 1.8, radius * 0.8);
                ctx.lineTo(radius * 1.6, radius * 0.2);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = borderColor;
                ctx.lineWidth = Math.max(2, radius * 0.08);
                ctx.stroke();
            } else {
                // ë‹¨ì¼ ê¼¬ë¦¬ (1-2ë‹¨ê³„)
                ctx.beginPath();
                ctx.moveTo(radius * 1.2, 0);
                ctx.lineTo(radius * 1.8, -radius * 0.6);
                ctx.lineTo(radius * 1.8, radius * 0.6);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = borderColor;
                ctx.lineWidth = Math.max(2, radius * 0.08);
                ctx.stroke();
            }

            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(-radius * 0.3, -radius * 0.2, radius * 0.15, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }
        
        function drawLevelCircle() {
            let centerX = 280;
            let centerY = 760;
            let radius = 25;

            // "ë ˆë²¨" í…ìŠ¤íŠ¸ í‘œì‹œ
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 16px "Noto Sans KR", Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ë ˆë²¨', centerX, centerY - 40);

            let progress = player.foodEaten / 5;

            ctx.fillStyle = '#2C3E50';
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.fill();

            if(progress > 0) {
                ctx.fillStyle = '#4A90E2';
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, -Math.PI/2, -Math.PI/2 + (progress * Math.PI * 2));
                ctx.lineTo(centerX, centerY);
                ctx.closePath();
                ctx.fill();
            }

            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.fillStyle = '#FFF';
            ctx.font = '20px "Noto Sans KR", Arial';
            ctx.textAlign = 'center';
            ctx.fillText(player.level.toString(), centerX, centerY + 6);
        }

        function drawStaminaBar() {
            let barX = 320;
            let barY = 760;
            let barWidth = 160;
            let barHeight = 12;

            let staminaPercent = player.stamina / player.maxStamina;

            ctx.fillStyle = '#2C3E50';
            ctx.fillRect(barX, barY, barWidth, barHeight);

            if(staminaPercent > 0) {
                let fillColor = player.isDashing ? '#FF6B6B' : '#4CAF50';
                ctx.fillStyle = fillColor;
                ctx.fillRect(barX, barY, barWidth * staminaPercent, barHeight);
            }

            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 2;
            ctx.strokeRect(barX, barY, barWidth, barHeight);

            ctx.fillStyle = '#FFF';
            ctx.font = '12px "Noto Sans KR", Arial';
            ctx.textAlign = 'left';
            ctx.fillText('ìŠ¤í…Œë¯¸ë‚˜', barX, barY - 3);
        }

        function drawFishGuide() {
            let startX = 80;
            let startY = 30;
            let spacing = 85;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(20, 10, 760, 60);

            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 1;
            ctx.strokeRect(20, 10, 760, 60);

            ctx.fillStyle = '#FFF';
            ctx.font = '12px "Noto Sans KR", Arial';
            ctx.textAlign = 'left';
            ctx.fillText('ë“±ì¥ ì˜ˆì •:', 25, 25);

            for(let i = 0; i < 8; i++) {
                let fishData = fishStages[i];
                let x = startX + i * spacing;
                let y = startY + 20;

                let willAppear = false;
                if(player.level >= 8) {
                    willAppear = true;
                } else {
                    willAppear = fishData.stage <= player.level + 1;
                }

                if(willAppear) {
                    let currentPlayerRadius = getPlayerRadius();
                    let isEnemy = (player.level < 8 && fishData.stage === player.level + 1) || currentPlayerRadius < fishData.radius;
                    drawFish(x, y, fishData.radius, fishData.color, -1, fishData.stage, isEnemy);
                } else {
                    ctx.fillStyle = '#666';
                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#AAA';
                    ctx.font = '10px "Noto Sans KR", Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('?', x, y + 3);
                }
            }

            if(player.level >= 6) {
                let sharkX = startX + 8 * spacing;
                let sharkY = startY + 20;

                drawShark(sharkX, sharkY, 12, 0, 0);

                ctx.fillStyle = '#FFF';
                ctx.font = '10px "Noto Sans KR", Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ìƒì–´', sharkX, sharkY + 18);
            }
        }

        function drawGameInfo() {
            // ìƒë‹¨ ìš°ì¸¡ ìŒì†Œê±° ë²„íŠ¼ë§Œ í‘œì‹œ
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.beginPath();
            ctx.arc(760, 30, 25, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#FFF';
            ctx.font = '22px "Noto Sans KR", Arial';
            ctx.textAlign = 'center';
            ctx.fillText(isMuted ? 'ğŸ”‡' : 'ğŸ”Š', 760, 38);

            // ì ìˆ˜ë¥¼ í•˜ë‹¨ì— í‘œì‹œ (ë ˆë²¨ ë™ê·¸ë¼ë¯¸ ì˜†)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(500, 745, 180, 40);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.strokeRect(500, 745, 180, 40);

            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 20px "Noto Sans KR", Arial';
            ctx.textAlign = 'left';
            ctx.fillText('ì ìˆ˜:', 515, 772);
            ctx.fillStyle = '#FFD700';
            ctx.fillText(player.score, 575, 772);
        }

        function drawTestButton() {
            // í™”ë©´ ìš°ì¸¡ í•˜ë‹¨ì— í…ŒìŠ¤íŠ¸ ë²„íŠ¼ í‘œì‹œ
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(680, 750, 110, 40);

            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 2;
            ctx.strokeRect(680, 750, 110, 40);

            ctx.fillStyle = '#FFF';
            ctx.font = '14px "Noto Sans KR", Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ë ˆë²¨ì—… (Lí‚¤)', 735, 775);
        }

        function drawShark(x, y, size, targetX, targetY) {
            ctx.save();
            ctx.translate(x, y);

            // ìƒì–´ê°€ í”Œë ˆì´ì–´ ë°©í–¥ì„ ë°”ë¼ë³´ë„ë¡ ì¢Œìš° ë°©í–¥ ì¡°ì •
            if (targetX < x) {
                ctx.scale(-1, 1); // ì™¼ìª½ì„ ë°”ë¼ë³¼ ë•Œ ì¢Œìš° ë’¤ì§‘ê¸°
            }
            
            ctx.fillStyle = '#708090';

            ctx.beginPath();
            ctx.ellipse(0, 0, size * 1.5, size * 0.6, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#FF0000';
            ctx.lineWidth = Math.max(2, size * 0.08);
            ctx.stroke();

            ctx.fillStyle = '#708090';
            ctx.beginPath();
            ctx.moveTo(-size * 1.5, 0);
            ctx.lineTo(-size * 2.2, -size * 0.8);
            ctx.lineTo(-size * 2.2, size * 0.8);
            ctx.closePath();
            ctx.fill();

            ctx.strokeStyle = '#FF0000';
            ctx.lineWidth = Math.max(2, size * 0.08);
            ctx.stroke();

            ctx.fillStyle = '#708090';
            ctx.beginPath();
            ctx.moveTo(0, -size * 0.6);
            ctx.lineTo(size * 0.5, -size * 1.0);
            ctx.lineTo(size * 0.3, -size * 0.6);
            ctx.closePath();
            ctx.fill();

            ctx.strokeStyle = '#FF0000';
            ctx.lineWidth = Math.max(2, size * 0.08);
            ctx.stroke();
            
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(size * 0.5, -size * 0.15, size * 0.08, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#FFF';
            for(let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.moveTo(size * 0.8 + i * size * 0.15, size * 0.2);
                ctx.lineTo(size * 0.7 + i * size * 0.15, size * 0.5);
                ctx.lineTo(size * 0.9 + i * size * 0.15, size * 0.2);
                ctx.closePath();
                ctx.fill();
            }
            
            ctx.restore();
        }

        function drawUrchin(x, y, radius) {
            ctx.save();
            ctx.translate(x, y);

            // ì„±ê²Œ ëª¸ì²´ (ë³´ë¼ìƒ‰ ì›)
            ctx.fillStyle = '#8B008B';
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fill();

            // ì™¸ê³½ì„ 
            ctx.strokeStyle = '#4B0082';
            ctx.lineWidth = 2;
            ctx.stroke();

            // ê°€ì‹œ 12ê°œ
            ctx.strokeStyle = '#6B006B';
            ctx.lineWidth = 3;
            for(let i = 0; i < 12; i++) {
                let angle = (i / 12) * Math.PI * 2;
                let startX = Math.cos(angle) * radius;
                let startY = Math.sin(angle) * radius;
                let endX = Math.cos(angle) * (radius + 10);
                let endY = Math.sin(angle) * (radius + 10);

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
            }

            // ì¤‘ì•™ì— ì‘ì€ ëˆˆ í‘œì‹œ
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(-5, -3, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(5, -3, 2, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function createParticle(x, y) {
            for(let i = 0; i < 5; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 30,
                    maxLife: 30
                });
            }
        }
        
        function drawBackground() {
            let gradient = ctx.createLinearGradient(0, 0, 0, 800);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(0.5, '#4682B4');
            gradient.addColorStop(1, '#191970');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 800, 800);
        }

        function drawIntroScreen() {
            ctx.fillStyle = '#2C3E50';
            ctx.font = 'bold 64px "Noto Sans KR", Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ì•„ê¸°ê³ ë˜ ì¿ ì•„', 400, 250);

            drawCua(400, 350, 50, 0, 0);

            ctx.fillStyle = '#4A90E2';
            ctx.font = '24px "Noto Sans KR", Arial';
            ctx.fillText('ì•„ë¬´ í‚¤ë‚˜ ëˆ„ë¥´ê±°ë‚˜ í´ë¦­í•´ì„œ ì‹œì‘í•˜ì„¸ìš”', 400, 500);

            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '18px "Noto Sans KR", Arial';
            ctx.fillText('ë°©í–¥í‚¤ ë˜ëŠ” ë§ˆìš°ìŠ¤ë¡œ ì´ë™í•˜ì—¬ ë¹¨ê°„ ë¬¼ê³ ê¸°ë¥¼ ë¨¹ê³  ì„±ì¥í•˜ì„¸ìš”!', 400, 540);
            ctx.fillText('ê²€ì€ ì ê³¼ íšŒìƒ‰ ìƒì–´ë¥¼ í”¼í•˜ì„¸ìš”! ìš°í´ë¦­ìœ¼ë¡œ ì¼ì‹œì •ì§€', 400, 570);
            ctx.fillText('ìŠ¤í˜ì´ìŠ¤ë°” ë˜ëŠ” ë§ˆìš°ìŠ¤ í´ë¦­ìœ¼ë¡œ ëŒ€ì‰¬! (ìŠ¤í…Œë¯¸ë‚˜ ì†Œëª¨)', 400, 600);

            // ì¸íŠ¸ë¡œ í™”ë©´ ì†Œë¦¬ ë²„íŠ¼
            ctx.fillStyle = '#6B6B6B';
            ctx.fillRect(720, 20, 60, 40);
            ctx.fillStyle = '#FFF';
            ctx.font = '24px "Noto Sans KR", Arial';
            ctx.fillText(isMuted ? 'ğŸ”‡' : 'ğŸ”Š', 750, 45);
        }
        
        function checkCollision(obj1, obj2) {
            let dx = obj1.x - obj2.x;
            let dy = obj1.y - obj2.y;
            return Math.sqrt(dx*dx + dy*dy) < (obj1.radius + obj2.radius);
        }
        
        function update() {
            if(gameState !== 'playing' || isPaused) return;
            
            let inputX = 0, inputY = 0;
            let keyboardMovement = false;

            player.isDashing = (keys[' '] || mousePressed || isDashPressed) && player.stamina > 5;
            let baseSpeed = player.isSlowed ? player.speed * 0.5 : player.speed; // ì„±ê²Œ ë””ë²„í”„ ì ìš©
            let maxSpeed = player.isDashing ? baseSpeed * 2.5 : baseSpeed;

            // í‚¤ë³´ë“œ ì…ë ¥ ê°ì§€
            if(keys['ArrowUp'] || keys['w'] || keys['W']) { inputY = -1; keyboardMovement = true; usingKeyboard = true; }
            if(keys['ArrowDown'] || keys['s'] || keys['S']) { inputY = 1; keyboardMovement = true; usingKeyboard = true; }
            if(keys['ArrowLeft'] || keys['a'] || keys['A']) { inputX = -1; keyboardMovement = true; usingKeyboard = true; }
            if(keys['ArrowRight'] || keys['d'] || keys['D']) { inputX = 1; keyboardMovement = true; usingKeyboard = true; }

            // í„°ì¹˜ ì…ë ¥ ì²˜ë¦¬ (ì†ê°€ë½ì´ í„°ì¹˜í•œ ê³³ìœ¼ë¡œ ì´ë™)
            if(!keyboardMovement && isTouching) {
                let dx = mouse.x - player.x;
                let dy = mouse.y - player.y;
                let distance = Math.sqrt(dx * dx + dy * dy);

                if(distance > 10) {
                    inputX = dx / distance;
                    inputY = dy / distance;
                    usingKeyboard = false;
                }
            }
            // ë§ˆìš°ìŠ¤ ì…ë ¥ ì²˜ë¦¬
            else if(!keyboardMovement && !usingKeyboard && !isTouching) {
                let dx = mouse.x - player.x;
                let dy = mouse.y - player.y;
                let distance = Math.sqrt(dx * dx + dy * dy);

                if(distance > 10) {
                    inputX = dx / distance;
                    inputY = dy / distance;
                }
            }

            // ë¶€ë“œëŸ¬ìš´ ê°€ì†/ê°ì† (ê´€ì„± ì ìš©)
            let acceleration = 0.4;
            let friction = 0.85;

            // ëª©í‘œ ì†ë„ ê³„ì‚°
            let targetVelocityX = inputX * maxSpeed;
            let targetVelocityY = inputY * maxSpeed;

            // ë¶€ë“œëŸ¬ìš´ ê°€ì†
            if(Math.abs(inputX) > 0.1) {
                player.velocityX += (targetVelocityX - player.velocityX) * acceleration;
            } else {
                player.velocityX *= friction; // ë§ˆì°° ì ìš©
            }

            if(Math.abs(inputY) > 0.1) {
                player.velocityY += (targetVelocityY - player.velocityY) * acceleration;
            } else {
                player.velocityY *= friction; // ë§ˆì°° ì ìš©
            }

            // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
            player.x += player.velocityX;
            player.y += player.velocityY;

            // ì´ë™ ë°©í–¥ ê¸°ë¡ (ê·¸ë¦¬ê¸°ìš©)
            if(Math.abs(player.velocityX) > 0.1 || Math.abs(player.velocityY) > 0.1) {
                player.lastMoveX = player.velocityX / maxSpeed;
                player.lastMoveY = player.velocityY / maxSpeed;
            }

            if(player.isDashing) {
                player.stamina -= 1.5;
                if(player.stamina <= 0) {
                    player.stamina = 0;
                    player.isDashing = false;
                }
            } else {
                player.stamina = Math.min(player.maxStamina, player.stamina + 0.2);
            }

            player.x = Math.max(player.radius, Math.min(800-player.radius, player.x));
            player.y = Math.max(player.radius, Math.min(800-player.radius, player.y));
            
            for(let i = fishes.length - 1; i >= 0; i--) {
                let fish = fishes[i];

                // AI í–‰ë™ íŒ¨í„´ ì¶”ê°€
                let currentPlayerRadius = getPlayerRadius();
                let dx = player.x - fish.x;
                let dy = player.y - fish.y;
                let distance = Math.sqrt(dx * dx + dy * dy);

                // ë¨¹ì´ ë¬¼ê³ ê¸° (ì‘ì€ ë¬¼ê³ ê¸°)ì˜ ë„ë§ í–‰ë™
                if(currentPlayerRadius >= fish.radius && distance < 80) {
                    let escapeSpeed = 0.4;
                    let escapeX = -dx / distance * escapeSpeed;
                    let escapeY = -dy / distance * escapeSpeed;
                    fish.speedX += escapeX * 0.2; // ê¸°ì¡´ ì†ë„ì— ë„ë§ ì†ë„ ì¶”ê°€
                    fish.speedY += escapeY * 0.2;
                }

                // ì  ë¬¼ê³ ê¸° (í° ë¬¼ê³ ê¸°)ì˜ ì¶”ì  í–‰ë™
                if(player.level < 8 && fish.stage === player.level + 1 && distance < 120) {
                    let chaseSpeed = 0.3;
                    let chaseX = dx / distance * chaseSpeed;
                    let chaseY = dy / distance * chaseSpeed;
                    fish.speedX += chaseX * 0.15; // ê¸°ì¡´ ì†ë„ì— ì¶”ì  ì†ë„ ì¶”ê°€
                    fish.speedY += chaseY * 0.15;
                }

                // ì†ë„ ì œí•œ (ë„ˆë¬´ ë¹¨ë¼ì§€ì§€ ì•Šë„ë¡)
                let maxSpeed = 1.2;
                let currentSpeed = Math.sqrt(fish.speedX * fish.speedX + fish.speedY * fish.speedY);
                if(currentSpeed > maxSpeed) {
                    fish.speedX = (fish.speedX / currentSpeed) * maxSpeed;
                    fish.speedY = (fish.speedY / currentSpeed) * maxSpeed;
                }

                fish.x += fish.speedX;
                fish.y += fish.speedY;
                fish.floatY += fish.floatSpeed;
                fish.y += Math.sin(fish.floatY) * fish.floatAmplitude * 0.1;

                if(fish.x < -50 || fish.x > 850 || fish.y < -50 || fish.y > 850) {
                    fishes.splice(i, 1);
                    continue;
                }

                if(checkCollision(player, fish)) {
                    let currentPlayerRadius = getPlayerRadius();

                    if(player.level < 8 && fish.stage === player.level + 1) {
                        if(!player.isInvincible) {
                            gameState = 'gameOver';
                            playSound(150, 1.0, 'sawtooth');
                            player.combo = 0;
                            stopBGM(); // ê²Œì„ì˜¤ë²„ ì‹œ BGM ì •ì§€
                        }
                    } else if(currentPlayerRadius >= fish.radius) {
                        createParticle(fish.x, fish.y);
                        fishes.splice(i, 1);

                        // ê²½í—˜ì¹˜ ê³„ì‚° (ë ˆë²¨ ì°¨ì´ì— ë”°ë¥¸ ê°ì†Œ)
                        let xpGain = 1;
                        let stageDifference = player.level - fish.stage;
                        if(stageDifference > 0) {
                            xpGain = Math.max(0.1, 1 - (stageDifference * 0.3));
                        }
                        player.foodEaten += xpGain;

                        // ì ìˆ˜ ê³„ì‚° (ë ˆë²¨ ì°¨ì´ì— ë”°ë¥¸ ê°ì†Œ)
                        let scoreGain = Math.floor(fish.points * xpGain);
                        player.score += scoreGain;

                        player.combo++;
                        player.radius = currentPlayerRadius;

                        let staminaGain = 0;
                        if(fish.stage <= 3) {
                            staminaGain = 34;
                        } else {
                            staminaGain = 100;
                        }
                        player.stamina = Math.min(player.maxStamina, player.stamina + staminaGain);

                        playSound(440 + player.combo * 50, 0.1, 'sine');

                        if(player.foodEaten >= 5) {
                            player.level++;
                            player.foodEaten = 0;
                            player.score += 50;
                            player.maxStamina += 20; // ë ˆë²¨ì—… ì‹œ ìµœëŒ€ ìŠ¤í…Œë¯¸ë‚˜ ì¦ê°€
                            player.stamina = player.maxStamina; // ìŠ¤í…Œë¯¸ë‚˜ ì™„ì „ íšŒë³µ
                            levelUpFlash = 30;
                            playSound(1200, 0.3, 'triangle');

                            // BGM ì—…ë°ì´íŠ¸ (ë ˆë²¨ì—… ì‹œ ìŒì•… ë³€í™”)
                            if(!isMuted) {
                                setTimeout(() => updateBGM(), 500);
                            }

                            if(player.level >= 6) {
                                warningTime = 120;
                            }

                            if(player.level >= 10) {
                                gameState = 'victory';
                                gameClearTime = Math.floor((Date.now() - gameStartTime) / 1000); // ì´ˆ ë‹¨ìœ„ë¡œ ì €ì¥
                                stopBGM(); // ìŠ¹ë¦¬ ì‹œ BGM ì •ì§€
                            }
                        }
                    }
                }
            }
            
            for(let i = sharks.length - 1; i >= 0; i--) {
                let shark = sharks[i];
                let dx = player.x - shark.x;
                let dy = player.y - shark.y;
                let distance = Math.sqrt(dx*dx + dy*dy);
                
                if(shark.x < -80 || shark.x > 880 || shark.y < -80 || shark.y > 880) {
                    sharks.splice(i, 1);
                    continue;
                }
                
                if(distance > 0) {
                    shark.x += (dx / distance) * shark.speed;
                    shark.y += (dy / distance) * shark.speed;
                }
                
                if(distance < (player.radius + shark.size) && !player.isInvincible) {
                    gameState = 'gameOver';
                    gameClearTime = Math.floor((Date.now() - gameStartTime) / 1000); // ê²Œì„ì˜¤ë²„ ì‹œê°„ ì €ì¥
                    playSound(150, 1.0, 'sawtooth');
                    player.combo = 0;
                    stopBGM(); // ê²Œì„ì˜¤ë²„ ì‹œ BGM ì •ì§€
                }
            }

            // ì„±ê²Œ ì—…ë°ì´íŠ¸ ë° ì¶©ëŒ ì²˜ë¦¬
            for(let i = urchins.length - 1; i >= 0; i--) {
                let urchin = urchins[i];

                // ìœ„ì•„ë˜ë¡œ ì´ë™
                urchin.x += urchin.speedX;
                urchin.y += urchin.speedY;

                // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ë©´ ì œê±°
                if(urchin.y < -40 || urchin.y > 840) {
                    urchins.splice(i, 1);
                    continue;
                }

                // ì¶©ëŒ ê°ì§€
                let dx = player.x - urchin.x;
                let dy = player.y - urchin.y;
                let distance = Math.sqrt(dx * dx + dy * dy);

                if(distance < (player.radius + urchin.radius + 10)) { // ê°€ì‹œ í¬í•¨
                    if(!player.isInvincible && !player.isSlowed) {
                        // í˜ë„í‹° ì ìš©
                        player.foodEaten = Math.max(0, player.foodEaten - 1); // ê²½í—˜ì¹˜ 1 ê°ì†Œ
                        player.stamina = Math.max(0, player.stamina - 30); // ìŠ¤í…Œë¯¸ë‚˜ 30 ê°ì†Œ
                        player.isSlowed = true;
                        player.slowTime = 180; // 3ì´ˆ (60fps ê¸°ì¤€)
                        playSound(200, 0.3, 'sawtooth');
                    }
                }
            }

            // ë””ë²„í”„ ì‹œê°„ ê°ì†Œ
            if(player.slowTime > 0) {
                player.slowTime--;
                if(player.slowTime <= 0) {
                    player.isSlowed = false;
                }
            }

            for(let i=powerUps.length-1; i>=0; i--) {
                let powerUp = powerUps[i];
                powerUp.x += powerUp.speedX;
                powerUp.y += powerUp.speedY;
                powerUp.floatY += powerUp.floatSpeed;
                powerUp.y += Math.sin(powerUp.floatY) * powerUp.floatAmplitude * 0.1;
                
                if(powerUp.x < -30 || powerUp.x > 830 || powerUp.y < -30 || powerUp.y > 830) {
                    powerUps.splice(i, 1);
                    continue;
                }
                
                if(checkCollision(player, powerUp)) {
                    powerUps.splice(i, 1);
                    player.isInvincible = true;
                    player.invincibleTime = 180;
                    player.score += 20;
                    playSound(600, 0.4, 'sawtooth');
                }
            }
            
            for(let i=bonusFish.length-1; i>=0; i--) {
                let bonus = bonusFish[i];
                bonus.x += bonus.speedX;
                bonus.y += bonus.speedY;
                bonus.floatY += bonus.floatSpeed;
                bonus.y += Math.sin(bonus.floatY) * bonus.floatAmplitude * 0.1;
                
                if(bonus.x < -30 || bonus.x > 830 || bonus.y < -30 || bonus.y > 830) {
                    bonusFish.splice(i, 1);
                    continue;
                }
                
                if(checkCollision(player, bonus)) {
                    createParticle(bonus.x, bonus.y);
                    bonusFish.splice(i, 1);
                    player.radius += 5;
                    player.score += 50;
                    playSound(400, 0.5, 'square');
                }
            }
            
            gameTime++;
            fishSpawnTimer++;

            let fishSpawnInterval = Math.max(60 - player.level * 5, 20);
            if(fishSpawnTimer >= fishSpawnInterval) {
                // ì´ˆê¸° ë ˆë²¨ì—ì„œëŠ” ë” ë§ì€ ë¬¼ê³ ê¸° ìŠ¤í°
                let spawnCount = player.level <= 3 ? 2 : 1;
                for(let i = 0; i < spawnCount; i++) {
                    spawnFish();
                }
                if(gameTime % 200 === 0) spawnPowerUp();
                fishSpawnTimer = 0;
            }
            
            sharkSpawnTimer++;
            let requiredSharks = 0;
            if(player.level >= 6 && player.level < 8) requiredSharks = 1;
            else if(player.level >= 8 && player.level < 10) requiredSharks = 2;
            else if(player.level >= 10) requiredSharks = 3;
            
            if(sharks.length < requiredSharks && sharkSpawnTimer >= 300) {
                spawnShark();
                sharkSpawnTimer = 0;
            }
            
            for(let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                if(p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
            
            if(warningTime > 0) warningTime--;
            if(levelUpFlash > 0) levelUpFlash--;
            
            if(player.invincibleTime > 0) {
                player.invincibleTime--;
                if(player.invincibleTime <= 0) {
                    player.isInvincible = false;
                }
            }
            
            // ì ìˆ˜ì™€ ë ˆë²¨ì€ ìº”ë²„ìŠ¤ì— ì§ì ‘ ê·¸ë ¤ì§
        }
        
        function draw() {
            drawBackground();
            
            if(levelUpFlash > 0) {
                ctx.fillStyle = `rgba(255, 255, 255, ${levelUpFlash / 30 * 0.3})`;
                ctx.fillRect(0, 0, 800, 800);
            }
            
            if(gameState === 'intro') {
                drawIntroScreen();
            } else if(gameState === 'playing') {
                drawCua(player.x, player.y, player.radius, player.lastMoveX, player.lastMoveY);

                fishes.forEach(fish => {
                    // ë¬¼ê³ ê¸°ëŠ” í•­ìƒ ì¢Œìš° ë°©í–¥ë§Œ ë³´ë„ë¡ í•¨
                    let direction = fish.speedX < 0 ? -1 : 1;
                    let currentPlayerRadius = getPlayerRadius();
                    let isEnemy = (player.level < 8 && fish.stage === player.level + 1) || currentPlayerRadius < fish.radius;
                    drawFish(fish.x, fish.y, fish.radius, fish.color, direction, fish.stage, isEnemy);
                });
                
                particles.forEach(p => {
                    let alpha = p.life / p.maxLife;
                    ctx.fillStyle = `rgba(255, 215, 0, ${alpha})`;
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(gameTime * 0.1);
                    ctx.beginPath();
                    ctx.moveTo(0, -3);
                    ctx.lineTo(-2, 1);
                    ctx.lineTo(2, 1);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                });

                // ë¬´ì  ì•„ì´í…œ (ë³„ ëª¨ì–‘)
                powerUps.forEach(powerUp => {
                    ctx.save();
                    ctx.translate(powerUp.x, powerUp.y);
                    ctx.rotate(gameTime * 0.05); // ì²œì²œíˆ íšŒì „

                    // ì™¸ê³½ ê¸€ë¡œìš° íš¨ê³¼
                    ctx.shadowColor = '#FFD700';
                    ctx.shadowBlur = 25;

                    // ë³„ ê·¸ë¦¬ê¸° (5ê°œ ê¼­ì§€ì )
                    ctx.fillStyle = '#FFD700';
                    ctx.strokeStyle = '#FFF';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    for(let i = 0; i < 5; i++) {
                        let angle = (i * 4 * Math.PI / 5) - Math.PI / 2;
                        let x = Math.cos(angle) * powerUp.radius;
                        let y = Math.sin(angle) * powerUp.radius;
                        if(i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // ì¤‘ì•™ í•˜ì–€ ë³„ ì‘ê²Œ
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    for(let i = 0; i < 5; i++) {
                        let angle = (i * 4 * Math.PI / 5) - Math.PI / 2;
                        let x = Math.cos(angle) * powerUp.radius * 0.4;
                        let y = Math.sin(angle) * powerUp.radius * 0.4;
                        if(i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();

                    ctx.restore();
                });
                
                bonusFish.forEach(bonus => {
                    // ë³´ë„ˆìŠ¤ ë¬¼ê³ ê¸°ë„ í•­ìƒ ì¢Œìš° ë°©í–¥ë§Œ ë³´ë„ë¡ í•¨
                    let direction = bonus.speedX < 0 ? -1 : 1;
                    drawFish(bonus.x, bonus.y, bonus.radius, '#FFD700', direction);
                });
                
                sharks.forEach(shark => {
                    drawShark(shark.x, shark.y, shark.size, player.x, player.y);
                });

                urchins.forEach(urchin => {
                    drawUrchin(urchin.x, urchin.y, urchin.radius);
                });
                
                if(warningTime > 0) {
                    ctx.fillStyle = '#FF4500';
                    ctx.font = '20px Arial';
                    ctx.textAlign = 'center';
                    if(player.level === 6) {
                        ctx.fillText('ë ˆë²¨ 6! ìƒì–´ ì¶œí˜„!', 400, 80);
                    } else if(player.level === 8) {
                        ctx.fillText('ë ˆë²¨ 8! ìƒì–´ ì¦ê°€!', 400, 80);
                    } else if(player.level === 10) {
                        ctx.fillText('ë ˆë²¨ 10! ìƒì–´ ëŒ€ê±° ì¶œí˜„!', 400, 80);
                    }
                }
                
                if(player.isInvincible) {
                    ctx.fillStyle = '#FF69B4';
                    ctx.font = '16px "Noto Sans KR", Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText('ë¬´ì : ' + Math.ceil(player.invincibleTime/60) + 'ì´ˆ', 20, 30);
                }
                
                drawLevelCircle();
                drawStaminaBar();
                drawFishGuide();
                drawTestButton();
                drawGameInfo();
                
                if(isPaused) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    ctx.fillRect(0, 0, 800, 800);

                    // í…ìŠ¤íŠ¸ ê·¸ë¦¼ì íš¨ê³¼
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                    ctx.shadowBlur = 10;
                    ctx.shadowOffsetX = 3;
                    ctx.shadowOffsetY = 3;

                    ctx.fillStyle = '#FFF';
                    ctx.font = 'bold 48px "Noto Sans KR", Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('ì¼ì‹œì •ì§€', 400, 300);

                    ctx.font = '20px "Noto Sans KR", Arial';
                    ctx.fillText('ESC í‚¤ ë˜ëŠ” ìš°í´ë¦­ìœ¼ë¡œ ì¬ê°œ', 400, 360);
                    ctx.fillText('í´ë¦­ìœ¼ë¡œ ì¬ê°œ', 400, 390);

                    // ê·¸ë¦¼ì íš¨ê³¼ ì œê±°
                    ctx.shadowBlur = 0;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;

                    // ë‹¤ì‹œì‹œì‘ ë²„íŠ¼
                    ctx.fillStyle = '#FF6B6B';
                    ctx.fillRect(220, 440, 120, 40);
                    ctx.fillStyle = '#FFF';
                    ctx.font = '16px "Noto Sans KR", Arial';
                    ctx.fillText('ë‹¤ì‹œì‹œì‘', 280, 465);

                    // í™ˆìœ¼ë¡œ ê°€ê¸° ë²„íŠ¼
                    ctx.fillStyle = '#4A90E2';
                    ctx.fillRect(360, 440, 120, 40);
                    ctx.fillStyle = '#FFF';
                    ctx.fillText('í™ˆìœ¼ë¡œ', 420, 465);

                    // ì†Œë¦¬ ë²„íŠ¼
                    ctx.fillStyle = '#6B6B6B';
                    ctx.fillRect(500, 440, 80, 40);
                    ctx.fillStyle = '#FFF';
                    ctx.font = '24px "Noto Sans KR", Arial';
                    ctx.fillText(isMuted ? 'ğŸ”‡' : 'ğŸ”Š', 540, 465);
                }
            } else if(gameState === 'gameOver') {
                drawCua(player.x, player.y, player.radius, player.lastMoveX, player.lastMoveY, true);

                // ë°˜íˆ¬ëª… ë°°ê²½
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, 800, 800);

                // í…ìŠ¤íŠ¸ ê·¸ë¦¼ì íš¨ê³¼
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetX = 3;
                ctx.shadowOffsetY = 3;

                ctx.fillStyle = '#FF6B6B';
                ctx.font = 'bold 48px "Noto Sans KR", Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Game Over', 400, 320);

                ctx.fillStyle = '#FFF';
                ctx.font = '24px "Noto Sans KR", Arial';
                ctx.fillText('ì ìˆ˜: ' + player.score, 400, 380);

                // ê²Œì„ì˜¤ë²„ ì‹œ í”Œë ˆì´ ì‹œê°„ í‘œì‹œ (ì €ì¥ëœ ì‹œê°„ ì‚¬ìš©)
                let minutes = Math.floor(gameClearTime / 60);
                let seconds = gameClearTime % 60;
                let timeString = minutes + ':' + (seconds < 10 ? '0' : '') + seconds;
                ctx.fillText('í”Œë ˆì´ ì‹œê°„: ' + timeString, 400, 420);

                ctx.font = '18px "Noto Sans KR", Arial';
                ctx.fillText('í´ë¦­ ë˜ëŠ” ìŠ¤í˜ì´ìŠ¤ë°”ë¥¼ ëˆŒëŸ¬ ì¬ì‹œì‘', 400, 470);

                // ê·¸ë¦¼ì íš¨ê³¼ ì œê±°
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
            } else if(gameState === 'victory') {
                // ë°˜íˆ¬ëª… ë°°ê²½
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, 800, 800);

                // í…ìŠ¤íŠ¸ ê·¸ë¦¼ì íš¨ê³¼
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetX = 3;
                ctx.shadowOffsetY = 3;

                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 48px "Noto Sans KR", Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ğŸ‰ Victory! ğŸ‰', 400, 320);

                ctx.fillStyle = '#FFF';
                ctx.font = '24px "Noto Sans KR", Arial';
                ctx.fillText('ë ˆë²¨ 10 ë‹¬ì„±!', 400, 380);
                ctx.fillText('ì ìˆ˜: ' + player.score, 400, 420);

                // í´ë¦¬ì–´ ì‹œê°„ í‘œì‹œ (ë¶„:ì´ˆ í˜•ì‹)
                let minutes2 = Math.floor(gameClearTime / 60);
                let seconds2 = gameClearTime % 60;
                let timeString2 = minutes2 + ':' + (seconds2 < 10 ? '0' : '') + seconds2;
                ctx.fillText('í´ë¦¬ì–´ ì‹œê°„: ' + timeString2, 400, 460);

                ctx.font = '18px "Noto Sans KR", Arial';
                ctx.fillText('í´ë¦­ ë˜ëŠ” ìŠ¤í˜ì´ìŠ¤ë°”ë¥¼ ëˆŒëŸ¬ ì¬ì‹œì‘', 400, 510);

                // ê·¸ë¦¼ì íš¨ê³¼ ì œê±°
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
            }
        }
        
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        function startGame() {
            player = {x:400, y:400, radius:8, speed:3, score:0, level:1, foodEaten:0, isInvincible:false, invincibleTime:0, combo:0, lastMoveX:0, lastMoveY:0, stamina:100, maxStamina:100, isDashing:false, velocityX:0, velocityY:0, isSlowed:false, slowTime:0};
            fishes = [];
            sharks = [];
            powerUps = [];
            bonusFish = [];
            particles = [];
            urchins = [];
            fishSpawnTimer = 0;
            sharkSpawnTimer = 0;
            gameTime = 0;
            gameStartTime = Date.now();
            gameClearTime = 0;
            levelUpFlash = 0;
            isPaused = false;
            usingKeyboard = false;

            for(let i=0; i<8; i++) {
                spawnFish();
            }
            // ì„±ê²Œ 2~3ê°œ ì´ˆê¸° ìŠ¤í°
            for(let i=0; i<3; i++) {
                spawnUrchin();
            }
            warningTime = 0;
            gameState = 'playing';

            // ì˜¤ë””ì˜¤ í™œì„±í™” (ëª¨ë°”ì¼)
            unlockAudio();

            // BGM ì‹œì‘
            if(!isMuted) {
                setTimeout(() => startBGM(), 100);
            }
        }

        function restartGame() {
            // BGM ì™„ì „íˆ ì •ì§€
            stopBGM();

            // ì¦‰ì‹œ ê²Œì„ ì‹œì‘ (ë”œë ˆì´ ì œê±°)
            startGame();
        }
        
        document.addEventListener('keydown', e => {
            keys[e.key] = true;

            if(gameState === 'intro') {
                startGame();
            } else if((gameState === 'gameOver' || gameState === 'victory') && e.key === ' ') {
                restartGame();
            }

            if(e.key === 'Escape') {
                if(gameState === 'playing') {
                    isPaused = !isPaused;
                    // ì¼ì‹œì •ì§€ ì‹œ BGM ì œì–´
                    if(isPaused) {
                        pauseBGM();
                    } else {
                        resumeBGM();
                    }
                }
            }

            // í…ŒìŠ¤íŠ¸ìš© ë ˆë²¨ì—… (Lí‚¤)
            if(e.key === 'l' || e.key === 'L') {
                if(gameState === 'playing' && player.level < 10) {
                    player.level++;
                    player.foodEaten = 0;
                    player.score += 50;
                    player.maxStamina += 20;
                    player.stamina = player.maxStamina;
                    levelUpFlash = 30;
                    playSound(1200, 0.3, 'triangle');

                    // BGM ì—…ë°ì´íŠ¸ (í…ŒìŠ¤íŠ¸ ë ˆë²¨ì—… ì‹œ)
                    if(!isMuted) {
                        setTimeout(() => updateBGM(), 500);
                    }

                    if(player.level >= 6) {
                        warningTime = 120;
                    }
                }
            }
        });
        document.addEventListener('keyup', e => keys[e.key] = false);
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;

            if(Math.abs(e.movementX) > 3 || Math.abs(e.movementY) > 3) {
                usingKeyboard = false;
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            // ìŒì†Œê±° ë²„íŠ¼ í´ë¦­ ê°ì§€ (ì›í˜• ë²„íŠ¼, ì¤‘ì‹¬: 760, 30, ë°˜ì§€ë¦„: 25)
            const muteButtonDistance = Math.sqrt(Math.pow(clickX - 760, 2) + Math.pow(clickY - 30, 2));
            if(muteButtonDistance <= 25 && (gameState === 'playing' || gameState === 'intro')) {
                toggleMute();
                return;
            }

            if(gameState === 'intro') {
                if(clickX >= 720 && clickX <= 780 && clickY >= 20 && clickY <= 60) {
                    // ì¸íŠ¸ë¡œ í™”ë©´ ì†Œë¦¬ ë²„íŠ¼ (ê¸°ì¡´ ìœ„ì¹˜)
                    toggleMute();
                } else {
                    startGame();
                    usingKeyboard = false;
                }
            } else if(gameState === 'gameOver' || gameState === 'victory') {
                restartGame();
            } else if(isPaused) {
                if(clickX >= 220 && clickX <= 340 && clickY >= 440 && clickY <= 480) {
                    // ë‹¤ì‹œì‹œì‘ ë²„íŠ¼
                    restartGame();
                } else if(clickX >= 360 && clickX <= 480 && clickY >= 440 && clickY <= 480) {
                    // í™ˆìœ¼ë¡œ ê°€ê¸° ë²„íŠ¼
                    gameState = 'intro';
                    isPaused = false;
                    stopBGM();
                } else if(clickX >= 500 && clickX <= 580 && clickY >= 440 && clickY <= 480) {
                    // ì†Œë¦¬ ë²„íŠ¼
                    toggleMute();
                } else {
                    // ì¼ì‹œì •ì§€ í•´ì œ
                    isPaused = false;
                    usingKeyboard = false;
                    resumeBGM();
                }
            } else if(gameState === 'playing') {
                mousePressed = true;
                usingKeyboard = false;
            }
        });

        canvas.addEventListener('mouseup', () => {
            mousePressed = false;
        });

        canvas.addEventListener('mouseleave', () => {
            mousePressed = false;  // ë§ˆìš°ìŠ¤ê°€ ìº”ë²„ìŠ¤ ë°–ìœ¼ë¡œ ë‚˜ê°€ë©´ ëŒ€ì‹œ ì¤‘ë‹¨
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            if(gameState === 'playing') {
                isPaused = !isPaused;
                // ì¼ì‹œì •ì§€ ì‹œ BGM ì œì–´
                if(isPaused) {
                    pauseBGM();
                } else {
                    resumeBGM();
                }
            }
        });

        // ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ ì˜ì—­
        const movementPad = document.getElementById('movementPad');
        const dashButton = document.getElementById('dashButton');
        const pauseButton = document.getElementById('pauseButton');

        // ì¼ì‹œì •ì§€ ë²„íŠ¼
        if(pauseButton) {
            pauseButton.addEventListener('click', (e) => {
                e.preventDefault();
                if(gameState === 'playing') {
                    isPaused = !isPaused;
                    if(isPaused) {
                        pauseBGM();
                        pauseButton.textContent = 'â–¶ï¸';
                    } else {
                        resumeBGM();
                        pauseButton.textContent = 'â¸ï¸';
                    }
                }
            });

            pauseButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if(gameState === 'playing') {
                    isPaused = !isPaused;
                    if(isPaused) {
                        pauseBGM();
                        pauseButton.textContent = 'â–¶ï¸';
                    } else {
                        resumeBGM();
                        pauseButton.textContent = 'â¸ï¸';
                    }
                }
            });
        }

        // ì´ë™ íŒ¨ë“œ
        if(movementPad) {
            movementPad.addEventListener('touchstart', (e) => {
                e.preventDefault();

                const rect = movementPad.getBoundingClientRect();
                const touch = e.touches[0];
                touchStartX = touch.clientX - rect.left;
                touchStartY = touch.clientY - rect.top;
                isTouching = true;

                // ê²Œì„ ì‹œì‘ (ì¸íŠ¸ë¡œ í™”ë©´ì¼ ë•Œ)
                if(gameState === 'intro') {
                    startGame();
                    usingKeyboard = false;
                } else if(gameState === 'gameOver' || gameState === 'victory') {
                    restartGame();
                }
            });

            movementPad.addEventListener('touchmove', (e) => {
                e.preventDefault();

                if(gameState !== 'playing' || isPaused) return;

                const rect = movementPad.getBoundingClientRect();
                const touch = e.touches[0];
                const currentX = touch.clientX - rect.left;
                const currentY = touch.clientY - rect.top;

                // í„°ì¹˜ ì‹œì‘ ì§€ì  ê¸°ì¤€ìœ¼ë¡œ ìƒëŒ€ì  ì´ë™
                const deltaX = (currentX - touchStartX) * 3;
                const deltaY = (currentY - touchStartY) * 3;

                mouse.x = player.x + deltaX;
                mouse.y = player.y + deltaY;
            });

            movementPad.addEventListener('touchend', (e) => {
                e.preventDefault();
                isTouching = false;
            });

            movementPad.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                isTouching = false;
            });
        }

        // ëŒ€ì‹œ ë²„íŠ¼
        if(dashButton) {
            dashButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isDashPressed = true;
                dashButton.classList.add('active');

                // ê²Œì„ ì‹œì‘ (ì¸íŠ¸ë¡œ í™”ë©´ì¼ ë•Œ)
                if(gameState === 'intro') {
                    startGame();
                    usingKeyboard = false;
                } else if(gameState === 'gameOver' || gameState === 'victory') {
                    restartGame();
                }
            });

            dashButton.addEventListener('touchend', (e) => {
                e.preventDefault();
                isDashPressed = false;
                dashButton.classList.remove('active');
            });

            dashButton.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                isDashPressed = false;
                dashButton.classList.remove('active');
            });
        }

        // í„°ì¹˜ ì´ë²¤íŠ¸ ì¶”ê°€ (ìº”ë²„ìŠ¤ìš©)
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchCount = e.touches.length;

            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const touchX = touch.clientX - rect.left;
            const touchY = touch.clientY - rect.top;

            // ê²Œì„ í™”ë©´ í¬ê¸°ì— ë§ê²Œ ì¢Œí‘œ ë³€í™˜
            const scaleX = 800 / rect.width;
            const scaleY = 800 / rect.height;
            mouse.x = touchX * scaleX;
            mouse.y = touchY * scaleY;

            isTouching = true;

            // ìŒì†Œê±° ë²„íŠ¼ í´ë¦­ ê°ì§€
            const muteButtonDistance = Math.sqrt(Math.pow(mouse.x - 760, 2) + Math.pow(mouse.y - 30, 2));
            if(muteButtonDistance <= 25 && (gameState === 'playing' || gameState === 'intro')) {
                toggleMute();
                return;
            }

            if(gameState === 'intro') {
                if(mouse.x >= 720 && mouse.x <= 780 && mouse.y >= 20 && mouse.y <= 60) {
                    toggleMute();
                } else {
                    startGame();
                    usingKeyboard = false;
                }
            } else if(gameState === 'gameOver' || gameState === 'victory') {
                restartGame();
            } else if(isPaused) {
                if(mouse.x >= 220 && mouse.x <= 340 && mouse.y >= 440 && mouse.y <= 480) {
                    restartGame();
                } else if(mouse.x >= 360 && mouse.x <= 480 && mouse.y >= 440 && mouse.y <= 480) {
                    gameState = 'intro';
                    isPaused = false;
                    stopBGM();
                } else if(mouse.x >= 500 && mouse.x <= 580 && mouse.y >= 440 && mouse.y <= 480) {
                    toggleMute();
                } else {
                    isPaused = false;
                    usingKeyboard = false;
                    resumeBGM();
                }
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            touchCount = e.touches.length;

            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const scaleX = 800 / rect.width;
            const scaleY = 800 / rect.height;
            mouse.x = (touch.clientX - rect.left) * scaleX;
            mouse.y = (touch.clientY - rect.top) * scaleY;
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            touchCount = e.touches.length;
            if(touchCount === 0) {
                isTouching = false;
            }
        });

        canvas.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            isTouching = false;
            touchCount = 0;
        });

        initAudio();
        gameLoop();
    </script>
</body>
</html>